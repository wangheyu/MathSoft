{"pdfpcFormat":1,"disableMarkdown":true,"noteFontSize":20,"pages":[{"idx":0,"label":"1","overlay":0,"note":"今天应该大都是研究生同学，也有一些本科生同学。我是数学学院计算数学专业的王何宇，我今没有开设研究生课程，所以可能大家都不太熟悉。不过还是对大家的勤奋好学表示钦佩。毕竟今天是周末，而大家还来捧场，让我深感惶恐。我不知道大家对这个报告有什么期待，希望不是两小时Python从入门到精通。但不管有什么期待，估计今天都要失望了。因为我到目前为止，还不是很清楚这场报告的性质。这个给我的感觉既不是一个公开报告，也不是学术报告，更不是上课。但好像又都搭点边..."},{"idx":1,"label":"2","overlay":0,"note":"总的来说，这次报告对我而言是一个命题作文。Python应用讲座。而且还列明了要基础、语法、机器学习和图像处理...这还是从入门到精通啊？我不太清楚到底是谁点的题，还这么具体。据说是有应同学要求的...这个就尴尬了。不清楚大家是从哪里看出我精通Python的，回头和我说一下，我马上就改。这个不是KTV点歌啊，大家点啥我就唱啥。事实上，真像是。我只用了3个月的Python，这个大约有80-90个14、15级本科同学可以证明。所以...似乎我们报告可以结束了？但既然大家来都来了，不如再听我胡扯几句？当然想要听从入门到精通的同学，恐怕真的要失望了。我们今天还是会讲Python，但主要是更大家分享和汇报一下我这3个月学习Python的一些个人体会。"},{"idx":2,"label":"2","overlay":1,"note":"总的来说，这次报告对我而言是一个命题作文。Python应用讲座。而且还列明了要基础、语法、机器学习和图像处理...这还是从入门到精通啊？我不太清楚到底是谁点的题，还这么具体。据说是有应同学要求的...这个就尴尬了。不清楚大家是从哪里看出我精通Python的，回头和我说一下，我马上就改。这个不是KTV点歌啊，大家点啥我就唱啥。事实上，真像是。我只用了3个月的Python，这个大约有80-90个14、15级本科同学可以证明。所以...似乎我们报告可以结束了？但既然大家来都来了，不如再听我胡扯几句？当然想要听从入门到精通的同学，恐怕真的要失望了。我们今天还是会讲Python，但主要是更大家分享和汇报一下我这3个月学习Python的一些个人体会。"},{"idx":3,"label":"3","overlay":0,"note":"也就是这些内容。这里我简单介绍一下我个人的背景，以供大家参考对照。我接触计算机倒是有很长的时间了。曾经在计算机学院上过C语言的课。然后调动到数学院以后，主要的工作是计算数学方面专业课程的教学以及科研。我的科研兴趣比较接近实际算法的设计和应用，比较讲究计算效率。因此不是很谦虚的说，我在C/C++方面有比较长时间的使用经历，大约20年。大家知道，在计算机领域，是很容易结党的。比如说用了很多年Windows的人，就很难转入Linux。而在使用Mac的眼里，其他一切系统的用户都是土豹子。编程语言尤其是如此。甚至连C语言和C++语言有时都会分成两国互相伤害。那么这里就有一个问题，作为一个资深的C党，我是如何发生动摇的呢？"},{"idx":4,"label":"4","overlay":0,"note":"我直接接触到Python，是在2014年访问英国利兹大学计算机学院的时候。我在那里的PDE Unit做了一年的访问学者。利兹大学的计算机学院，有庞大的图形学和可视化研究团队，而这些同事几乎清一色地使用Python。这使我第一次开始注意到Python的重要性。毕竟，一个有重要国际地位的研究团队的选择还是值得我关注的。当然当时我并不知道我们浙江大学的很多计算机团队也早就用Python了。我在那里是个另类，因为我用的是C++。那些老外经常用怜悯的眼神看着我，然后嘟囔着：Once you have tried Python, you will never go back to C++...但我并不为此所动，毕竟我已经使用了这么长久的C++，并且积累了不少代码，我不太可能在主要科研工作中转移一门语言，所以我也没有考虑继续学习Python。但这件事情的转机发生在今年。我从去年起开设了一门本科生课程——算法语言。由于是新课，我一直在摸索和调整上课的内容。去年，我使用的语言是C++，然而我个人感觉效果不太好。C++太技术化了，于是我面临一个困难的选择，一方面我不想让学生把主要精力放在语言学习上，因为这门课更重要的是算法而不是一门具体的语言。但另一方面。我又不得不讲述大量的语言和技术，因为算法的实现必须要依赖具体的语言。这里格外让我觉得尴尬的是，究竟有多少学生会在课程结束之后还继续使用C++呢？ 事实上，这一点和我们的日常工作遇到的困境也很像。我们大家都有各自的专业，然后又都希望能把主要的精力集中到专业研究中去。计算机在我们的研究中都有重要的地位，但是计算机技术本身的学习和熟练，却几乎占据了我们一半以上的时间。以至于有时我们会疑惑自己究竟是一个数学专业的学生还是一个码农。做码农本身不是问题，但如果你是希望变成一个应用数学家或这计算化学家，结果一不留神成为了码农，那就有点搞笑了。我不想在我的课程中加强这种倾向，于是我开始考虑是否有可能尽量减轻学生在具体计算机技术掌握的负担，利兹大学的经历提醒我，也许可以考虑一下Python。所以我开始阅读各种文档，并尝试构建我的第一个Python程序。很奇怪，居然不是一个Hello  World!"},{"idx":5,"label":"4","overlay":1,"note":"我直接接触到Python，是在2014年访问英国利兹大学计算机学院的时候。我在那里的PDE Unit做了一年的访问学者。利兹大学的计算机学院，有庞大的图形学和可视化研究团队，而这些同事几乎清一色地使用Python。这使我第一次开始注意到Python的重要性。毕竟，一个有重要国际地位的研究团队的选择还是值得我关注的。当然当时我并不知道我们浙江大学的很多计算机团队也早就用Python了。我在那里是个另类，因为我用的是C++。那些老外经常用怜悯的眼神看着我，然后嘟囔着：Once you have tried Python, you will never go back to C++...但我并不为此所动，毕竟我已经使用了这么长久的C++，并且积累了不少代码，我不太可能在主要科研工作中转移一门语言，所以我也没有考虑继续学习Python。但这件事情的转机发生在今年。我从去年起开设了一门本科生课程——算法语言。由于是新课，我一直在摸索和调整上课的内容。去年，我使用的语言是C++，然而我个人感觉效果不太好。C++太技术化了，于是我面临一个困难的选择，一方面我不想让学生把主要精力放在语言学习上，因为这门课更重要的是算法而不是一门具体的语言。但另一方面。我又不得不讲述大量的语言和技术，因为算法的实现必须要依赖具体的语言。这里格外让我觉得尴尬的是，究竟有多少学生会在课程结束之后还继续使用C++呢？ 事实上，这一点和我们的日常工作遇到的困境也很像。我们大家都有各自的专业，然后又都希望能把主要的精力集中到专业研究中去。计算机在我们的研究中都有重要的地位，但是计算机技术本身的学习和熟练，却几乎占据了我们一半以上的时间。以至于有时我们会疑惑自己究竟是一个数学专业的学生还是一个码农。做码农本身不是问题，但如果你是希望变成一个应用数学家或这计算化学家，结果一不留神成为了码农，那就有点搞笑了。我不想在我的课程中加强这种倾向，于是我开始考虑是否有可能尽量减轻学生在具体计算机技术掌握的负担，利兹大学的经历提醒我，也许可以考虑一下Python。所以我开始阅读各种文档，并尝试构建我的第一个Python程序。很奇怪，居然不是一个Hello  World!"},{"idx":6,"label":"4","overlay":2,"note":"我直接接触到Python，是在2014年访问英国利兹大学计算机学院的时候。我在那里的PDE Unit做了一年的访问学者。利兹大学的计算机学院，有庞大的图形学和可视化研究团队，而这些同事几乎清一色地使用Python。这使我第一次开始注意到Python的重要性。毕竟，一个有重要国际地位的研究团队的选择还是值得我关注的。当然当时我并不知道我们浙江大学的很多计算机团队也早就用Python了。我在那里是个另类，因为我用的是C++。那些老外经常用怜悯的眼神看着我，然后嘟囔着：Once you have tried Python, you will never go back to C++...但我并不为此所动，毕竟我已经使用了这么长久的C++，并且积累了不少代码，我不太可能在主要科研工作中转移一门语言，所以我也没有考虑继续学习Python。但这件事情的转机发生在今年。我从去年起开设了一门本科生课程——算法语言。由于是新课，我一直在摸索和调整上课的内容。去年，我使用的语言是C++，然而我个人感觉效果不太好。C++太技术化了，于是我面临一个困难的选择，一方面我不想让学生把主要精力放在语言学习上，因为这门课更重要的是算法而不是一门具体的语言。但另一方面。我又不得不讲述大量的语言和技术，因为算法的实现必须要依赖具体的语言。这里格外让我觉得尴尬的是，究竟有多少学生会在课程结束之后还继续使用C++呢？ 事实上，这一点和我们的日常工作遇到的困境也很像。我们大家都有各自的专业，然后又都希望能把主要的精力集中到专业研究中去。计算机在我们的研究中都有重要的地位，但是计算机技术本身的学习和熟练，却几乎占据了我们一半以上的时间。以至于有时我们会疑惑自己究竟是一个数学专业的学生还是一个码农。做码农本身不是问题，但如果你是希望变成一个应用数学家或这计算化学家，结果一不留神成为了码农，那就有点搞笑了。我不想在我的课程中加强这种倾向，于是我开始考虑是否有可能尽量减轻学生在具体计算机技术掌握的负担，利兹大学的经历提醒我，也许可以考虑一下Python。所以我开始阅读各种文档，并尝试构建我的第一个Python程序。很奇怪，居然不是一个Hello  World!"},{"idx":7,"label":"5","overlay":0,"note":"因为我是从C++转过来的。所以很自然地，我开始胡乱地写一些对象。我大概花了10分钟才明白，在Python中，缩进就代表模块，也就好比C++中的大花括号。一旦明白之后，对我到没有太大的困扰，因为我从来就是使用K&R缩进风格的，恰好和Python的要求一致。但Python这种处理模块的方式仍然让我觉得眼前一亮。显然，在C语言本身不强调风格，但是谁都明白好的习惯必须强调一致的风格。那为何不干脆将其用语法固定下来呢？然而接下去发现Python不需要先定义后使用这一点，却使我略感不安。比如这里的成员变量以及初始化，我甚至没有显式指定类型，但它们确实其作用。Python中，大量存在这种隐式声明的情况。我们知道，从严格性上讲，这样可能造成不一致而产生bug，但这种不一致能否通过其他方式消除呢。我注意到另一个细节就是Python中的约定。比如这里的__init__和self，这些严格的说，不是语法，而是约定。但这是大家都遵守的约定。如果严格遵循这些约定，那么很多由隐式声明造成的不一致是可以尽量避免的。事实上，多年的C语言编程经验告诉我，严格的显式声明，并不能避免不一致和bug的发生。有时甚至会增加bug的可能。毕竟完全依赖编译器来维持这种先定义后使用的规则，让程序变得非常的死板和不易维护，而一旦作出妥协，如C90和C++里那样，允许局部定义，则又可能引入更多的错误。所以既然一切还要依赖程序员来控制，那么也许尽量降低程序员的负担，是一个可以考虑的方向。放弃严格的显式声明，可以让程序尽快跑起来，同时让整个程序显得更短，这些都能降低程序员的负担。"},{"idx":8,"label":"6","overlay":0,"note":"Python的另一个降低程序员负担的做法是大量采用类自然语言，也就是英语。相信即便是从来没学过Python的人，对这些代码也不会有任何疑惑。当然，这同时也形成了另一种约定，尽可能靠近自然语言，包括变量、函数、类等标识符的命名。而隐式声明在这里有提供了新的优势，我们可以更自由地组织代码次序，使其更接近自然语言。"},{"idx":9,"label":"7","overlay":0,"note":"顺便说说我的程序写到这里还在乱写。我给一个物体赋以质量、位置、速度、加速度和受力。要不了多久我就打算写一个宇宙出来。"},{"idx":10,"label":"8","overlay":0,"note":"Python在面向对象方面毫无压力。因此除了基本属性以外，物体的基本运动规律也很容易实现。当然我随手写的就只有一阶。"},{"idx":11,"label":"9","overlay":0,"note":"我基本上不打算写一个比高中物理课本中的小球更复杂的对象。这个时候随着文档阅读的增加，我发现我似乎可以将我生成的小球真实地在屏幕这个二维世界中绘制出来。于是我开始像所有Python程序那样，导入一些外挂库，用以处理向量、数据、绘图和动画。我不知道为何要动画。我只是明白在C语言中，动画完全是个体力活，我看到的Python程序都不太长，所以我想也许这个会很容易。我继续胡乱地赋了一些常数。"},{"idx":12,"label":"10","overlay":0,"note":"然后我遇到一个问题，当我把一个物体从抽象类具体化，那么我必须给出具体的数值，如我可以定义一个地球，然后就要给出它的质量、初始位置、初始加速度，等等。这些参数可以用形参输入，也可以用一个参数文件导入。如果用参数文件导入，那么就涉及文件格式，解码，字符串转数值，等等一系列的技术活。凡是用C语言、Fortran甚至Matlab的人都有过类似的经历。这些读参数的技术活，谈不上有什么难度。但确实很令人厌烦，特别是有时还要花费大量的时间去检查为什么我读进来的数字都变成乱码这种令人格外沮丧的事情。那么在Python当中，我发现情况有所好转。对于大部分常用的文件格式，Python几乎都提供了相应接口，比如这里json.loads就是针对Java Script的输入格式。我们接下去还会看到别的格式的引入。"},{"idx":13,"label":"11","overlay":0,"note":"而我的具体数据文件是这样的，它符合json格式，它和程序中对应变量的关系，一目了然。再一次显示了Python在使用上的便利和可读性。"},{"idx":14,"label":"12","overlay":0,"note":"接下去我构建一个图形。这一段代码我是直接参考文档中的示例。但再一次，Python的可读性起了作用。这种可读性不但降低了代码调试和维护的困难，对于新学Python的人而言，也是一个福利。"},{"idx":15,"label":"13","overlay":0,"note":"这也许是整个程序中最有技巧的部分。如何在模型上让物体在引力下动起来，特别是如果有多个物体，考虑它们的相互作用。但恰好，这个反而是我最熟悉的部分。估计对在座的很多同学而言，这也是简单的。我这里直接写了一个针对这种Halmiton系统的向前Euler求解。我当然用C语言写过类似的程序，但是一发面算法本身淹没在C语言的格式化语法中，很难看清。另一方面，其结果也就是一串数字列表，想要绘制成图形，经常都需要再打开一个专门的绘图软件如Tecplot或Matlab。"},{"idx":16,"label":"14","overlay":0,"note":"当然这是一个很粗浅的求解器，我甚至没有考虑各种守恒性质。毕竟，我只是想随便写点不那么无趣的东西，然后看看能否掌握Python。让我们直接看看效果。嗯，这是一个双星系统。"},{"idx":17,"label":"15","overlay":0,"note":"这里当然你可以和我讨论，比如Python不是做这件事效率最高的语言。但我也不是可视化专家或游戏软件专家。我这辈子都不太可能在这些方面做到顶级，但是，有可能在教学或科研中，我也需要偶尔用一下这些技能。那么在这样的情形下，为何不用Python 呢？事实上我会接受任何可以让我实现目标的软件，哪怕它是盗版的...毕竟，Python还没有版权一说。"},{"idx":18,"label":"15","overlay":1,"note":"这里当然你可以和我讨论，比如Python不是做这件事效率最高的语言。但我也不是可视化专家或游戏软件专家。我这辈子都不太可能在这些方面做到顶级，但是，有可能在教学或科研中，我也需要偶尔用一下这些技能。那么在这样的情形下，为何不用Python 呢？事实上我会接受任何可以让我实现目标的软件，哪怕它是盗版的...毕竟，Python还没有版权一说。"},{"idx":19,"label":"15","overlay":2,"note":"这里当然你可以和我讨论，比如Python不是做这件事效率最高的语言。但我也不是可视化专家或游戏软件专家。我这辈子都不太可能在这些方面做到顶级，但是，有可能在教学或科研中，我也需要偶尔用一下这些技能。那么在这样的情形下，为何不用Python 呢？事实上我会接受任何可以让我实现目标的软件，哪怕它是盗版的...毕竟，Python还没有版权一说。"},{"idx":20,"label":"15","overlay":3,"note":"这里当然你可以和我讨论，比如Python不是做这件事效率最高的语言。但我也不是可视化专家或游戏软件专家。我这辈子都不太可能在这些方面做到顶级，但是，有可能在教学或科研中，我也需要偶尔用一下这些技能。那么在这样的情形下，为何不用Python 呢？事实上我会接受任何可以让我实现目标的软件，哪怕它是盗版的...毕竟，Python还没有版权一说。"},{"idx":21,"label":"15","overlay":4,"note":"这里当然你可以和我讨论，比如Python不是做这件事效率最高的语言。但我也不是可视化专家或游戏软件专家。我这辈子都不太可能在这些方面做到顶级，但是，有可能在教学或科研中，我也需要偶尔用一下这些技能。那么在这样的情形下，为何不用Python 呢？事实上我会接受任何可以让我实现目标的软件，哪怕它是盗版的...毕竟，Python还没有版权一说。"},{"idx":22,"label":"15","overlay":5,"note":"这里当然你可以和我讨论，比如Python不是做这件事效率最高的语言。但我也不是可视化专家或游戏软件专家。我这辈子都不太可能在这些方面做到顶级，但是，有可能在教学或科研中，我也需要偶尔用一下这些技能。那么在这样的情形下，为何不用Python 呢？事实上我会接受任何可以让我实现目标的软件，哪怕它是盗版的...毕竟，Python还没有版权一说。"},{"idx":23,"label":"15","overlay":6,"note":"这里当然你可以和我讨论，比如Python不是做这件事效率最高的语言。但我也不是可视化专家或游戏软件专家。我这辈子都不太可能在这些方面做到顶级，但是，有可能在教学或科研中，我也需要偶尔用一下这些技能。那么在这样的情形下，为何不用Python 呢？事实上我会接受任何可以让我实现目标的软件，哪怕它是盗版的...毕竟，Python还没有版权一说。"},{"idx":24,"label":"16","overlay":0,"note":"很多时候，Python像个万精油，它丰富的外挂包几乎覆盖了各种领域，从统计分析到无人机开发...一般而言，面太广的，必然不可能太深入。样样有，样样都不精是最有可能的结果。Python是否是如此呢？为此我稍微深入一下了解Python在和我研究最密切的科学计算领域的情况。我们注意到，Python中有3个针对科学计算和相应可视化的包。它也像Matlab那样，提供了大量的日常前后处理的功能，如绘图，等等。那么它在科学计算的核心问题，矩阵计算上表现如何？特别是和Matlab相比如何？让我们做几个小测试。examples/lin 我们看到python拥有豪不逊色Matlab的计算能力。我们仔细观察一下python的运行库。我们会发现其中带有mkl的支持。即便是我自己用C语言构建求解器，我能考虑的最高效率计算库也就是mkl，而python显然已经在底层实现了和mkl的对接，因此它具有和Matlab几乎一样的计算效率。换言之，我自己用C语言写求解器，在这种一般问题上不可能比python计算效率更高。这一事实让我很惊讶。因为至少在我最熟悉的一个领域，python几乎已经做到了当前技术可能做到的极致。同时，我还考察了对于数学相关专业而言，非常重要的一种应用：符号计算。顺便，我这里也要引入一种更便于展示的python形式：jupter-notebook。"},{"idx":25,"label":"16","overlay":1,"note":"很多时候，Python像个万精油，它丰富的外挂包几乎覆盖了各种领域，从统计分析到无人机开发...一般而言，面太广的，必然不可能太深入。样样有，样样都不精是最有可能的结果。Python是否是如此呢？为此我稍微深入一下了解Python在和我研究最密切的科学计算领域的情况。我们注意到，Python中有3个针对科学计算和相应可视化的包。它也像Matlab那样，提供了大量的日常前后处理的功能，如绘图，等等。那么它在科学计算的核心问题，矩阵计算上表现如何？特别是和Matlab相比如何？让我们做几个小测试。examples/lin 我们看到python拥有豪不逊色Matlab的计算能力。我们仔细观察一下python的运行库。我们会发现其中带有mkl的支持。即便是我自己用C语言构建求解器，我能考虑的最高效率计算库也就是mkl，而python显然已经在底层实现了和mkl的对接，因此它具有和Matlab几乎一样的计算效率。换言之，我自己用C语言写求解器，在这种一般问题上不可能比python计算效率更高。这一事实让我很惊讶。因为至少在我最熟悉的一个领域，python几乎已经做到了当前技术可能做到的极致。同时，我还考察了对于数学相关专业而言，非常重要的一种应用：符号计算。顺便，我这里也要引入一种更便于展示的python形式：jupter-notebook。"},{"idx":26,"label":"16","overlay":2,"note":"很多时候，Python像个万精油，它丰富的外挂包几乎覆盖了各种领域，从统计分析到无人机开发...一般而言，面太广的，必然不可能太深入。样样有，样样都不精是最有可能的结果。Python是否是如此呢？为此我稍微深入一下了解Python在和我研究最密切的科学计算领域的情况。我们注意到，Python中有3个针对科学计算和相应可视化的包。它也像Matlab那样，提供了大量的日常前后处理的功能，如绘图，等等。那么它在科学计算的核心问题，矩阵计算上表现如何？特别是和Matlab相比如何？让我们做几个小测试。examples/lin 我们看到python拥有豪不逊色Matlab的计算能力。我们仔细观察一下python的运行库。我们会发现其中带有mkl的支持。即便是我自己用C语言构建求解器，我能考虑的最高效率计算库也就是mkl，而python显然已经在底层实现了和mkl的对接，因此它具有和Matlab几乎一样的计算效率。换言之，我自己用C语言写求解器，在这种一般问题上不可能比python计算效率更高。这一事实让我很惊讶。因为至少在我最熟悉的一个领域，python几乎已经做到了当前技术可能做到的极致。同时，我还考察了对于数学相关专业而言，非常重要的一种应用：符号计算。顺便，我这里也要引入一种更便于展示的python形式：jupter-notebook。"},{"idx":27,"label":"16","overlay":3,"note":"很多时候，Python像个万精油，它丰富的外挂包几乎覆盖了各种领域，从统计分析到无人机开发...一般而言，面太广的，必然不可能太深入。样样有，样样都不精是最有可能的结果。Python是否是如此呢？为此我稍微深入一下了解Python在和我研究最密切的科学计算领域的情况。我们注意到，Python中有3个针对科学计算和相应可视化的包。它也像Matlab那样，提供了大量的日常前后处理的功能，如绘图，等等。那么它在科学计算的核心问题，矩阵计算上表现如何？特别是和Matlab相比如何？让我们做几个小测试。examples/lin 我们看到python拥有豪不逊色Matlab的计算能力。我们仔细观察一下python的运行库。我们会发现其中带有mkl的支持。即便是我自己用C语言构建求解器，我能考虑的最高效率计算库也就是mkl，而python显然已经在底层实现了和mkl的对接，因此它具有和Matlab几乎一样的计算效率。换言之，我自己用C语言写求解器，在这种一般问题上不可能比python计算效率更高。这一事实让我很惊讶。因为至少在我最熟悉的一个领域，python几乎已经做到了当前技术可能做到的极致。同时，我还考察了对于数学相关专业而言，非常重要的一种应用：符号计算。顺便，我这里也要引入一种更便于展示的python形式：jupter-notebook。"},{"idx":28,"label":"16","overlay":4,"note":"很多时候，Python像个万精油，它丰富的外挂包几乎覆盖了各种领域，从统计分析到无人机开发...一般而言，面太广的，必然不可能太深入。样样有，样样都不精是最有可能的结果。Python是否是如此呢？为此我稍微深入一下了解Python在和我研究最密切的科学计算领域的情况。我们注意到，Python中有3个针对科学计算和相应可视化的包。它也像Matlab那样，提供了大量的日常前后处理的功能，如绘图，等等。那么它在科学计算的核心问题，矩阵计算上表现如何？特别是和Matlab相比如何？让我们做几个小测试。examples/lin 我们看到python拥有豪不逊色Matlab的计算能力。我们仔细观察一下python的运行库。我们会发现其中带有mkl的支持。即便是我自己用C语言构建求解器，我能考虑的最高效率计算库也就是mkl，而python显然已经在底层实现了和mkl的对接，因此它具有和Matlab几乎一样的计算效率。换言之，我自己用C语言写求解器，在这种一般问题上不可能比python计算效率更高。这一事实让我很惊讶。因为至少在我最熟悉的一个领域，python几乎已经做到了当前技术可能做到的极致。同时，我还考察了对于数学相关专业而言，非常重要的一种应用：符号计算。顺便，我这里也要引入一种更便于展示的python形式：jupter-notebook。"}]}